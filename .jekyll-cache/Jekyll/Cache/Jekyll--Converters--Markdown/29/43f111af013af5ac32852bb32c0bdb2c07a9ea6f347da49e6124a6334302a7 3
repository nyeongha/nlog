I"T<h2 id="11-자료구조와-알고리즘">1.1 자료구조와 알고리즘</h2>

<h3 id="자료구조란">자료구조란?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로그램에서 자료들을 정리하여 보관하는 여러가지 구조를 자료구조라한다.
</code></pre></div></div>

<h3 id="컴퓨터-프로그램은-무엇으로-이루어져있을까">컴퓨터 프로그램은 무엇으로 이루어져있을까?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로그램=자료구조+알고리즘
대부분의 프로그램에서 자료를 처리하고 있고 이들 자료는 자료구조를 사용하여 저장된다.
또한 주어진 문제를 처리하는 절차가 필요하다.이것은 알고리즘이라고 불린다.

자료구조와 알고리즘은 밀접한 관계가 있어서 자료구조가 결정되면 그 자료구조에서 사용할 수 있는 알고리즘이 결정된다.
컴퓨터가 복잡한 자료들을 빠르게 저장,검색,분석,전송,갱신하기 위해서는 자료구조가 효율적으로 조직화되어 있어야 한다.
각 응용에 가장 적합한 자료구조와 알고리즘을 선택해야한다.
</code></pre></div></div>

<h3 id="알고리즘이란">알고리즘이란?</h3>

<ul>
  <li>컴퓨터로 문제를 풀기 위한 단계적인 절차</li>
  <li>문제와 컴퓨터가 주어진 상태에서 문제를 해결하는 밤법을 장치가 이해할수있는 언어로 기술한 것</li>
  <li>특정한 일을 수행하는 명령어(컴퓨터에서 수행되는 문장)들의 집합</li>
</ul>

<h3 id="알고리즘이-되기-위한-조건">알고리즘이 되기 위한 조건</h3>

<ul>
  <li>입력:0개이상의 입력이 존재하여야 한다.</li>
  <li>출력:1개 이상의 출력이 존재하여야 한다.</li>
  <li>명백성:각 명령어의 의미는 모호하지않고 명확해야 한다.</li>
  <li>유한성:한정됨 수의 단계 후에는 반드시 종료되어야 한다.</li>
  <li>유효성:각 명령어들은 종이와 연필,또는 컴퓨터로 실행 가능한 연산이어야 한다.</li>
</ul>

<h3 id="알고리즘을-기술하는-4가지-방법">알고리즘을 기술하는 4가지 방법</h3>

<ol>
  <li>한글이나 영어같은 자연어</li>
  <li>흐름도(folwchart)</li>
  <li>의사코드(pseudo-code):자연어보다 더 체계적이고 프로그래밍 언어보다는 덜 엄격한 언어로서 알고리즘을 기술하는 데만 사용되는 코드를 말한다.다만 대입연산자가 =가 아닌 &lt;-임을 유의하라.</li>
  <li>프로그래밍 언어:예약어들은 모두 명백한 의미를 가지고 있음.</li>
</ol>

<h3 id="quizp17">quiz(p.17)</h3>

<ol>
  <li>문제를 풀기위한 단계적인 절차는 [알고리즘]이다.</li>
  <li>알고리즘을 기술하기 위한 방법에는 자연어,흐름도,[의사코드],프로그래밍 언어가 있다.</li>
  <li>알고리즘이 되기 위한 조건이 아닌것은?[4]
    <ol>
      <li>출력</li>
      <li>명백성</li>
      <li>유효성</li>
      <li>반복성</li>
    </ol>
  </li>
</ol>

<h2 id="1-2-추상-자료형">1-2 추상 자료형</h2>

<h3 id="c언어에서-제공하는-자료형">C언어에서 제공하는 자료형</h3>

<ul>
  <li>정수</li>
  <li>실수</li>
  <li>문자</li>
  <li>배열(동일한 자료형이 여러개 모인 것)</li>
  <li>구조체(다른 자료형이 여러개 모인 것)</li>
</ul>

<p><b><span style="background-color: #F7DDBE">자료형이라하면 데이터뿐만아니라 데이터간에 가능한 연산도 고려하여야한다</span></b></p>

<h3 id="추상화란">추상화란?</h3>

<ul>
  <li>어떤 시스템의 간략화된 기술 또는 명세</li>
  <li>시스템의 정말 핵심적인 구조나 동작에만  집중하는 것</li>
  <li>좋은 추상화는 사용자에게 중요한 정보는 강조되고 반면 중요하지않은 구현 세부사항은 제거되는 것</li>
  <li>이를 위해 정보은닉 기법이 개발-&gt;추상자료형(ADT)의 개념으로 발</li>
</ul>

<h3 id="adt추상자료형캡슐화정보은닉">ADT(추상자료형,캡슐화,정보은닉)</h3>

<ul>
  <li>실제적인 구형으로부터 분리되어 정의된 자료형을 뜻함</li>
  <li>자료형을 추상적으로 정의함을 의미</li>
  <li>데이터나 연산이 무엇인지는 정의되지만 데이터나 연산을 어떻게 컴퓨터상에서 구현할 것인지는 정의되지 않음</li>
  <li>연산을 정의할 떄 연산의 이름,매개 변수,반환형은 정의하지만 연산을 구현하는 구체적인 코드는 주어지지않는것</li>
  <li>다만 연산을 정의하는 추상적인 의사 코드는 주어질 수 있음</li>
  <li>ADT안에는 객체와 함수들이 정의된다.</li>
  <li>객체는 주로 집합의 개념을 사용하여 정의되고, 이후 함수(연산)들이 정의된다.</li>
  <li>구현 세부사항은 외부에 알리지않고 외부와의 인터페이스만을 공개하게된다.</li>
  <li>사용자는 구현세부사항이 아닌 인터페이스만 사용하기 떄문에 추상 자료형의 구현방법은 언제든지 안전하게 변경될 수 있다.</li>
  <li>인터페이스만 정확하게 지켜진다면 ADT가 여러가지 방법으로 구현될 수 있음을 뜻한다.</li>
  <li>전체 프로그램을 변경가능성이 있는 구현의 세부사항으로부터 보호하는 것이다.</li>
  <li>구현으로부터 명세의 분리가 ADT의 핵심 아이디어이다.</li>
  <li>adt의 객체는 클래스의 속성으로 구현되고 adt의 연산은 클래스의 멤버함수로 구현된다.</li>
  <li>객체 지향언어에서는 private나 protected키워드를 이용하여 내부 자료의 접근을 제한할 수 있다.</li>
  <li>클래스는 계층구조(상속개념사용)로 구성될 수 있다.</li>
</ul>

<h3 id="quizp21">quiz(p.21)</h3>

<ul>
  <li>01.자료형은 객체와 이객체간의 연산의 집합으로 정의된다.</li>
  <li>02.추상자료형은 객체와 연산들의 명세가 구현으로부터 분리된 자료형을 말한다.</li>
  <li>Nat_No추상자료형에 is_greater(x,y)연산을 추가하여보자.</li>
</ul>

<blockquote>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>is_greater(x,y) ::= if(x&gt;y) return TRUE;
                   else return FALSE;
</code></pre></div>  </div>
  <blockquote>
    <p>특수 기호인’::=’는 ‘정의된다’를 의미한다. 
구문 구조 이름인 좌측이 ‘::=’기호 다음에 따르는 우측으로 대체될 수 있다는 의미이다.</p>
  </blockquote>
</blockquote>

<h2 id="13-알고리즘-성능-분석">1.3 알고리즘 성능 분석</h2>

<ul>
  <li>최근 상용 프로그램의 규모가 이전에 비해서 엄청나게 커지고 있어 처리해야할 자료의 양이 많기 떄문에 알고리즘의 효율성은 더욱 중요하게 된다.</li>
  <li>사용자들은 빠른 프로그램을 선호하기 때문에 프로그래머는 하드웨어와 상관없이 소프트웨어적으로 최선의 효율성을 갖는 프로그램을 제작하도록 노력하여야 할 것 이다.</li>
  <li>효율적인 알고리즘이란 알고리즘을 시작하여 결과가 나올 때까지의 수행시간이 짧으면서 컴퓨터 내에 있는 메모리와 같은 자원을 덜 사용하는 알고리즘이다.</li>
</ul>

<h3 id="알고리즘-복잡도-분석-방법">알고리즘 복잡도 분석 방법</h3>

<ul>
  <li>알고리즘 복잡도 분석은 구현하지 않고도 모든 입력을 고려하는 방법이고 실행 하드웨어나 소프트웨어 환경과는 관계없이 알고리즘의 효율성을 평가할 수 있다.</li>
</ul>

<h3 id="시간-복잡도-함수">시간 복잡도 함수</h3>

<ul>
  <li>알고리즘의 수행시간 분석을 시간 복잡도(time complexity)라고 하고 알고리즘이 사용하는 기억 공간 분석을 공간 복잡도(space complexity)라고 한다.</li>
  <li>알고리즘의 복잡도를 이야기할때 대게는 시간 복잡도를 말한다.</li>
  <li>알고리즘이 차지하는 공간보다는 수행시간에 더 관심이 있기 때문이다.</li>
  <li>일반적으로 연산의 수행횟수는 고정된 숫자가 아니라 n에 대한 함수가 된다.</li>
  <li>연산의 수를 입력의 개수 n의 함수로 나타낸 것을 시간 복잡도 함수라고 하고 T(n)이라고 표기한다.</li>
</ul>

<h3 id="빅오-표기법">빅오 표기법</h3>

<ul>
  <li>입력 자료의 개수가 큰경우에는 차수가 가장 큰 항이 전체의 값을 주도하기때문에 시간 복잡도 함수에서 차수가 가장 큰 항만을 고려하면 충분하다.</li>
  <li>시간 복잡도 함수에서 중요한것은 n이 증가하였을 때에, 연산의 총 횟수가 n에 비레하여 증가하는지,아니면 n²에 비례하여 증가하는지,아니면 다른 증가추세를 가지는지가 더 중요하다.</li>
  <li>시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을 빅오 표기법이라고 한다.</li>
  <li>알고리즘이 n에 비례하는 수행시간을 가진다고 말하는 대신에 시간복잡도가O(n)이라고 한다.(‘빅오 of n’이라고 읽음)</li>
  <li>빅오 표기법을 사용하면 시간 복잡도 함수의 증가에 별로 기여하지 못하는 항을 생략함으로쎠 시간 복잡도를 간단하게 표시할 수 있다.</li>
</ul>

<figure style="text-align:center">
<img src="https://t1.daumcdn.net/cfile/tistory/246F3F3E590B81B234" height="20%" width="50%" />
</figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>두개의 함수 f(n)과 g(n)이 주어졌을때, 
n&gt;n₀에 대하여 |f\(n)|&lt;=c|g\(n)|을 만족하는 2개의 상수 c와 n₀가 존재하면 
f(n)=O(g(n))이다.
위의 그래프에서 f(n)의 값은 n이 매우 커지게 되면 결국 g(n)보다 작거나 같게 된다.
따라서 이 정의는 g(n)이 f(n)의 상한값이라는것을 의미한다.
</code></pre></div></div>

<h3 id="빅오표기법-이외의-표기법">빅오표기법 이외의 표기법</h3>

<ul>
  <li>빅오 표기법은 상한을 표기한것이므로 상한은 여러개가 존재할 수 있다.그러나 빅오표기법이 최소 함수로 표기되었을 경우만 의미가 있다.</li>
  <li>이와 같은 문제점을 보완하기 위하여 빅오메가와 빅쎄타 표기 법이 있다.</li>
  <li>빅오메가는 어떤 함수의 하한을 표시하는 방법이다.</li>
</ul>

<figure style="text-align:center">
<img src="https://i.stack.imgur.com/5qDtj.png" height="40%" width="50%" />


    두개의 함수 f(n)과 g(n)이 주어졌을때, 
    모든 n&gt;n₀에 대하여,
    |f\(n)|&gt;=c|g\(n)|을 만족하는 2개의 상수 c와 n₀가 존재하면,
    f(n)=Ω(g(n))이다.
</figure>

<ul>
  <li>빅쎄타는 동일한 함수로 상한과 하한을 만들 수 있는 경우,즉 f(n)=O(g(n))이고,f(n)=Ω(g(n))인 경우를 f(n)=Θ(g(n))이라 한다.</li>
</ul>

<figure style="text-align:center">
<img src="https://www.simplilearn.com/ice9/free_resources_article_thumb/Soni-Article-new/theta-notation-in-space-and-time-complexity.jpg" height="20%" width="60%" />

    두개의 함수 f(n)과 g(n)이 주어졌을때,
    모든 n&gt;n₀에 대하여,c₁|g\(n)|&lt;=|f\(n)|&lt;=c₂|g\(n)|을 만족하는 3개의 c₁,c₂와 n₀가 존재하면,
    f(n)=Θ(g(n))이다.

</figure>
<figure style="text-align:center">
<img src="https://blog.kakaocdn.net/dn/blKM2B/btrwIpP1gho/MfLDU37IeMbUJXMIVn63B1/img.png" height="30%" width="70%" />
<figcaption>3개의 표기법 비교</figcaption>

    가장 정밀한것은 빅세타 이다.
    그러나 통상적으로 빅오 표기법을 많이 사용한다.
    단 그때는 최소차수로 상한을 표시한다고 가정하자.


</figure>

<h3 id="최선평균최악의-경우">최선,평균,최악의 경우</h3>

<ul>
  <li>수행시간을 얘기할때 평균적인 수행시간을 구하는것이 가장 좋아보이지만,광범위한 자료집합에 대하여 알고리즘을 적용시켜서 평균값을 계산하는것은 상당히 힘들다</li>
  <li>따라서 최악의 경우의 수행시간이 알고리즘의 시간 복잡도 척도로 많이 쓰인다.</li>
  <li>최악의 경우란 입력 자료 집합을 알고리즘에 최대한 불리하도록 만들어서 얼마만큼의 시간이 소모되는 지를 분석하는 것이다.</li>
</ul>

<h3 id="quizp35다음의-시간-복잡도-함수를-빅오-표기법으로-표시하라">(quiz,p.35)다음의 시간 복잡도 함수를 빅오 표기법으로 표시하라</h3>

<ol>
  <li>
    <p>9n²+8n+1</p>

    <p>답:O(n²)</p>
  </li>
  <li>
    <p>n!+2ⁿ</p>

    <p>답:O(n!)</p>
  </li>
  <li>
    <p>n²+nlog₂n+1</p>

    <p>답:O(n²)</p>
  </li>
  <li>
    <p>$\sum_{i=1}^{n}i^{2}$
$=\frac{n(1+n^{2})}{2}$</p>

    <p>답:O($n^{3}$)</p>
  </li>
</ol>

<h2 id="연습문제p36">연습문제(p.36)</h2>

<ol>
  <li>
    <p>2개의 정수를 서로 교환하는 알고리즘을 의사코드로 작성해보자.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> swap(a,b)
     tmp&lt;-a
     a&lt;-b
     b&lt;-tmp
     return(a,b)
</code></pre></div>    </div>
  </li>
  <li>
    <p>사용자로부터 받은 2개의 정수 중에서 더 큰 수를 찾는 알고리즘을 의사코드로 작성해보자.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> max(a,b)
     if (a&gt;b) then
         return a
     else
         return b
</code></pre></div>    </div>
  </li>
  <li>
    <p>1부터 n까지의 합을 계산하는 알고리즘을 의사코드로 작성해보자.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> sum(n)
     for i&lt;-1 to n do
         sum&lt;-sum+i
     return sum
</code></pre></div>    </div>
  </li>
  <li>
    <p>Set(집합) 추상 자료형을 정의하라. 다음과 같은 연산자들을 포함 시켜라.(Create,Insert,Remove,Is_In,Union,Intersection,Difference)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 객체 정의 : 집합은 원소(element)라 불리우는 데이터 요소들의 모임 

 연산 정의 : 

 Create() := 집합을 생성하여 반환한다. 

 Insert(S, item) := 원소 item을 집합 S에 저장한다. 

 Remove(S, item) := 원소 item를 집합 S에서 삭제한다. 

 Is_In(S, item) := 집합 S에 item이 있는지를 검사한다. 

 Union(S1, S2) := S1과 S2의 합집합을 구한다. 

 Intersection(S1, S2) := S1과 S2의 교집합을 구한다. 

 Difference(S1, S2) := S1과 S2의 차집합을 구한다. 

 ​
</code></pre></div>    </div>
  </li>
  <li>
    <p>Boolean 추상자료형을 정의하고 다음과 같은 연산자들을 포함 시켜라.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 객체정의 : 0과 1 

 연산정의 :

 And(b1, b2) := b1=1 이고 b2=1 이면 1을 반환하고, 아니면 0을 반환한다. 

 Or(b1, b2) := b1=1 이거나 b2=1이면 1을 반환하고, 아니면 0을 반환한다.

 Not(b) := b=0 이면 1을 반환한다. b=1이면 0을 반환한다. 

 Xor(b1, b2) := (b1=1 이고 b2=1) 이거나 (b1=0 이고 b2=0) 이면 0을 반환하고, 아니면 1을 반환한다.
</code></pre></div>    </div>
  </li>
  <li>
    <p>다음과 같은 코드의 시간 복잡도는? 여기서 n이 프로그램의 입력이라고 가정하자.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> for(i=1,i&lt;n;i*=2)---&gt;log₂n
     print("hello")---&gt;1
    
 f(n)=log₂n+1
 O(n)=log₂n
</code></pre></div>    </div>
  </li>
  <li>
    <p>다음과 같은 코드의 시간 복잡도는?여기서 n이 프로그램의 입력이라고 가정하자.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> for (i=0,i&lt;n;i++)-------&gt;n
     for(j=1,j&lt;n;j*=2)----&gt;log₂n
         print("hello")----&gt;1

 f(n)=nlog₂n+1
 O(n)=nlog₂n
</code></pre></div>    </div>
  </li>
  <li>시간 복잡도 함수 n²+10n+8를 빅오 표기법으로 나타내면?(답:3.O(n²))
    <ol>
      <li>O(n)</li>
      <li>O(nlog₂n)</li>
      <li>O(n²)</li>
      <li>O(n²log₂n)</li>
    </ol>
  </li>
  <li>시간 복잡도 함수가 7n+10이라면 이것이 나타내는 것은 무엇인가?(답:1.연산의 횟수)
    <ol>
      <li>연산의 횟수</li>
      <li>프로그램의 수행시간</li>
      <li>프로그램이 차지하는 메모리의 양</li>
      <li>입력 데이터의 총개수</li>
    </ol>
  </li>
  <li>O(n²)의 시간 복잡도를 가지는 알고리즘에서 입력의 개수가 2배로 되었다면 실행시간은 어떤 추세로 증가하는가?(답:3.4배)
    <ol>
      <li>변함없다.</li>
      <li>2배</li>
      <li>4배</li>
      <li>8배</li>
    </ol>
  </li>
  <li>f(n)에 대하여 엄격한 상한을 제공하는 표기법은 무엇인가?(답:2.빅오)
    <ol>
      <li>빅오메가</li>
      <li>빅오</li>
      <li>빅세타</li>
      <li>존재하지않음</li>
    </ol>
  </li>
  <li>
    <p>다음의 빅오 표기법들을 수행시간이 적게 걸리는것부터 나열하라.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O(1)    O(n)    O(log n)    O(n²)   O(nlog n)    O(n!)    O(2ⁿ)
답:O(1) ,O(log n),O(n),O(nlog n),O(n²),O(2ⁿ),(n!)
</code></pre></div>    </div>
  </li>
  <li>
    <p>두 함수 30n+4와 n²를 여러가지 n값으로 비교하라. 언제 30n+4가 n²보다 작은 값을 갖는지를 구하라.그래프를 그려보라.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>풀이:30n+4 &lt; n² 근의 공식을 이용하여 n을 구하면 n=30.x이후부터 30n+4가 작아지는것을 알수있다.
답:n이 30보다 클경우 30n+4가 n²보다 커진다.
</code></pre></div>    </div>
  </li>
  <li>
    <p>다음은 실제로 프로그램의 수행시간을 측정하여 도표로 나타낸 것이다.</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">입력의 개수n</th>
          <th style="text-align: center">수행시간(초)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">2</td>
          <td style="text-align: center">2</td>
        </tr>
        <tr>
          <td style="text-align: center">4</td>
          <td style="text-align: center">8</td>
        </tr>
        <tr>
          <td style="text-align: center">8</td>
          <td style="text-align: center">25</td>
        </tr>
        <tr>
          <td style="text-align: center">16</td>
          <td style="text-align: center">63</td>
        </tr>
        <tr>
          <td style="text-align: center">32</td>
          <td style="text-align: center">162</td>
        </tr>
      </tbody>
    </table>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(n)=an+b라고 하고 n을 대입후 a,b를 구하면 f(n)=3n-4가 나온다.
g(n)=n이므로 이 프로그램의 시간 복잡도는 O(n)이다.
</code></pre></div>    </div>
  </li>
  <li>
    <p>빅오 표기법의 정의를 사용하여 다음을 증명하라.</p>

    <blockquote>
      <p>5n²+3=O(n²)
g(n)=n²</p>
      <blockquote>
        <table>
          <tbody>
            <tr>
              <td>빅오표기법의 정의에 따르면,n&gt;n₀에 대하여</td>
              <td>f(n)</td>
              <td>&lt;=c</td>
              <td>g(n)</td>
              <td>을 만족하는 2개의 상수 c와 n₀가 존재하면 f(n)=O(g(n))이다.</td>
            </tr>
            <tr>
              <td>그러므로 n&gt; $\sqrt 3$ 에 대하여</td>
              <td>5n²+3</td>
              <td>&lt;=6</td>
              <td>n²</td>
              <td>을 만족하므로 5n²+3=O(n²)이다.</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
    </blockquote>
  </li>
  <li>
    <p>빅오 표기법의 정의를 이용하여 6n²+3n이 O(n)이 될수 없음을 보여라.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>빅오표기법의 정의에 따르면,n&gt;n₀에 대하여 |f\(n)|&lt;=c|g\(n)|을 만족하는 2개의 상수 c와 n₀가 존재하면 f(n)=O(g(n))이다.
</code></pre></div>    </div>

    <blockquote>
      <p>여기서 g(n)=n이다.
n&gt;n₀에 대하여 |6n²+3n|&lt;=c|n|을 만족하는 c와 n₀가 없으므로,
6n²+3n이 O(n)이 될수 없다.</p>
    </blockquote>
  </li>
  <li>배열에 정수가 들어있다고 가정하고 다음의 작업의 최악,최선의 시간 복잡도를 빅오 표기법으로 말하라.
    <ol>
      <li>배열의 n번째 숫자를 화면에 출력한다.[최선:O(1),최악:O(1)]</li>
      <li>배열안의 숫자 중에서 최소값을 찾는다.[최선:O(1),최악:O(n)]</li>
      <li>배열의 모든 숫자를 더한다.[최선:O(n),최악:O(n)]</li>
    </ol>
  </li>
</ol>
:ET